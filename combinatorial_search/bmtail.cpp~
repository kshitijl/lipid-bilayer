#include <iostream>
#include <ctime>
#include <cassert>
#include <map>
#include <vector>

using namespace std;

class DebugLog {
public:
    bool dbgOn;

    DebugLog() {
        dbgOn = true;
    }
    
    template <class T>
    DebugLog &operator<<(const T &x) {
        if(dbgOn) {
            cout << x;
            cout.flush();
        }
        
        return *this;
    }
};

DebugLog dlog;

class Point {
    friend ostream & operator<<(ostream &, const Point &);
    friend DebugLog & operator<<(DebugLog &, const Point &); 
public:
    int x, y;
    Point(int a, int b) { x = a; y = b; }

    // puts neighbor of this point in the given output vector
    int get_neighbors(vector<Point>& out) {
        out.reserve(4);
        out[0] = Point(x-1, y);
        out[1] = Point(x+1, y);
        out[2] = Point(x, y-1);
        out[3] = Point(x, y+1);
                    
        return 4;
    }

    Point get_next(Point bound) {
        if(bound < *this || bound == *this)
            return bound;
        if(y < bound.y)
            return Point(x, y+1);
        return Point(x+1,0);
    }

    bool operator<(const Point & b) const {
        if(x != b.x)
            return x < b.x;
        return y < b.y;
    }

    bool operator==(const Point & b) const {
        return x == b.x and y == b.y;
    }
     
};

ostream & operator<<(ostream & osObject, const Point & rightOp)
{
    osObject << "{" << rightOp.x << ", " << rightOp.y << "}";
    return osObject;
}

DebugLog & operator<<(DebugLog & osObject, const Point & rightOp)
{
    osObject << "{" << rightOp.x << ", " << rightOp.y << "}";
    return osObject;
}


class TailPlacer {
public

    bool try_point(Point p) {
        add_red(p);
        bool doable = decide();

        if(!doable)
            remove_red(p);

        return doable;
    }
};

void print_solution(TailPlacer &tp, int k) {
    for(int i = 0; i < k; i++) {
        for(int j = 0; j < k; j++) {
            if(tp.reds.find(Point(i,j)) != tp.reds.end())
                cout << ".";
            else
                cout << " ";
        }
        cout << "\n";
    }    
}

class GandT {
public:
    TailPlacer tp;
    int n;
    Point search_box;
    int lower_bound, upper_bound;
    vector<Point>solution;
    clock_t before, after;

    GandT(int _n, Point p) : search_box(p) { n = _n; lower_bound = 0; solution.reserve(n); }

    void begin() {
        Point first = Point(0,0);
        upper_bound = (3*n-4)/2;
        
        before = clock();
        solution[0] = first;
        tp.add_red(first);
        search(1);
    }
    
    bool search(int level) {
        if(lower_bound == upper_bound)
          return true;
        if(!tp.decide())
            return false;
        // TODO: if bounded return false
        if(level == n) {
            if(tp.get_contacts() >= lower_bound) {
                after = clock();
                cout << "Found solution with " << tp.get_contacts()
                     << " at " << (double)(after-before)/CLOCKS_PER_SEC << "\n";
                cout << "Time spent on DLX: " << (double)tp.dlx_time/CLOCKS_PER_SEC << "\n";
                print_solution(tp, 2*n);
                cout << "\n";
                cout.flush();
                lower_bound = tp.get_contacts();
            }
            return true;
        }

        bool result = false;
        
        // get the point after the one placed in the last level
        Point place = solution[level-1];

        while(!(place == search_box)) {
            place = place.get_next(search_box);

            if(tp.contacts_with(place) > tp.get_contacts()) {
                tp.add_red(place);
                solution[level] = place;
                bool tmp  = search(level+1);
                result = result || tmp;
                tp.remove_red(place);
            }
        }

        return result;
    }
};

int main(void) {
    GandT searcher(20, Point(7, 80));
    dlog.dbgOn = false;
    searcher.begin();
    
    return 0;
}

/*
With 20, (7, 80):
Found solution with 28 at 24.6655
Time spent on DLX: 8.03786
..........                              
..........  
 */
